import requests
import time
import csv
import os
import schedule
from datetime import datetime, timedelta
from telegram import Bot
from dotenv import load_dotenv
from utils.upbit import get_all_krw_symbols, get_daily_candles
from utils.indicators import calculate_rsi, calculate_macd, calculate_ma, calculate_volatility_ratio, calculate_drawdown

# í™˜ê²½ë³€ìˆ˜ ë¡œë“œ
load_dotenv()
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
CHAT_ID = os.getenv("CHAT_ID")

bot = Bot(token=TELEGRAM_TOKEN)
SWING_LOG = "upbit_logs/swing_candidates.csv"
POSITION_LOG = "upbit_logs/swing_positions.csv"

# ìŠ¤ìœ™ ì‹œê°„ ì„¤ì •
SWING_SCAN_TIME = "09:05"
SWING_POSITION_TIME = "09:07"
ANALYZE_POSITION_TIME = "09:10"

# ìŠ¤ìœ™ í›„ë³´ ì €ì¥ í•¨ìˆ˜
# ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì½”ì¸ì„ íŒŒì¼ë¡œ ê¸°ë¡í•¨
def save_swing_candidate(coin, rsi, macd, signal, vol_ratio, price):
    if not os.path.exists("upbit_logs"):
        os.makedirs("upbit_logs")
    file_exists = os.path.isfile(SWING_LOG)
    with open(SWING_LOG, mode='a', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        if not file_exists:
            writer.writerow(["date", "coin", "rsi", "macd", "signal", "vol_ratio", "price"])
        writer.writerow([datetime.now().strftime('%Y-%m-%d'), coin, rsi, macd, signal, vol_ratio, price])

# ìŠ¤ìœ™ í¬ì§€ì…˜ ì €ì¥ í•¨ìˆ˜
# ë§¤ìˆ˜ í¬ì§€ì…˜ì„ ë‚ ì§œë³„ë¡œ ì €ì¥í•˜ê³  í–¥í›„ ì¶”ì 
def save_swing_position(coin, entry_price):
    file_exists = os.path.isfile(POSITION_LOG)
    with open(POSITION_LOG, mode='a', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        if not file_exists:
            writer.writerow(["date", "coin", "entry_price"] + [f"D+{i}" for i in range(1, 8)])
        writer.writerow([datetime.now().strftime('%Y-%m-%d'), coin, entry_price] + ["" for _ in range(7)])

# ì „ë‚  í›„ë³´ ë¶ˆëŸ¬ì˜¤ê¸° í•¨ìˆ˜
# ì—°ì† ì¡°ê±´ í™•ì¸ì— ì‚¬ìš©ë¨
def load_previous_candidates():
    if not os.path.exists(SWING_LOG):
        return set()
    yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
    candidates = set()
    with open(SWING_LOG, newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            if row['date'] == yesterday:
                candidates.add(row['coin'])
    return candidates

# í¬ì§€ì…˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
# ë§¤ì¼ í˜„ì¬ê°€ë¥¼ í¬ì§€ì…˜ì— ê¸°ë¡
def update_swing_positions():
    if not os.path.exists(POSITION_LOG):
        return
    updated_rows = []
    with open(POSITION_LOG, newline='', encoding='utf-8') as f:
        reader = csv.reader(f)
        headers = next(reader)
        rows = list(reader)
    for row in rows:
        entry_date = datetime.strptime(row[0], "%Y-%m-%d")
        coin = row[1]
        entry_price = float(row[2])
        days_elapsed = (datetime.now() - entry_date).days
        if 1 <= days_elapsed <= 7 and row[2 + days_elapsed] == "":
            try:
                url = f"https://api.upbit.com/v1/ticker?markets=KRW-{coin}"
                res = requests.get(url)
                res.raise_for_status()
                current_price = res.json()[0]['trade_price']
                row[2 + days_elapsed] = str(current_price)
            except:
                continue
        updated_rows.append(row)
    with open(POSITION_LOG, mode='w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerow(headers)
        writer.writerows(updated_rows)

# 7ì¼ê°„ ìˆ˜ìµ ë¶„ì„ í•¨ìˆ˜
# ìŠ¤ìœ™ ì¢…ë£Œ í›„ ì„±ê³¼ ìš”ì•½ ë©”ì‹œì§€ë¥¼ ì „ì†¡
def analyze_completed_positions():
    if not os.path.exists(POSITION_LOG):
        return
    rows_to_keep = []
    with open(POSITION_LOG, newline='', encoding='utf-8') as f:
        reader = csv.reader(f)
        headers = next(reader)
        for row in reader:
            if all(row[3:10]):
                coin = row[1]
                entry_price = float(row[2])
                prices = list(map(float, row[3:10]))
                max_price = max(prices)
                min_price = min(prices)
                end_price = prices[-1]
                max_rise = (max_price - entry_price) / entry_price * 100
                max_fall = (min_price - entry_price) / entry_price * 100
                final_rise = (end_price - entry_price) / entry_price * 100
                message = (
                    f"ğŸ“Š [{coin} ìŠ¤ìœ™ ê²°ê³¼ ìš”ì•½]\n"
                    f"ì§„ì…ê°€: {entry_price:.2f}ì›\n"
                    f"7ì¼ê°„ ê³ ì : {max_price:.2f}ì› ({max_rise:.2f}%)\n"
                    f"7ì¼ê°„ ì €ì : {min_price:.2f}ì› ({max_fall:.2f}%)\n"
                    f"ì¢…ë£Œê°€: {end_price:.2f}ì› ({final_rise:.2f}%)"
                )
                bot.send_message(chat_id=CHAT_ID, text=message)
            else:
                rows_to_keep.append(row)
    with open(POSITION_LOG, mode='w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerow(headers)
        writer.writerows(rows_to_keep)

# ìŠ¤ìœ™ ìŠ¤ìº” í•¨ìˆ˜
# ì§€í‘œ ê¸°ë°˜ ì¡°ê±´ ë§Œì¡± ì‹œ ì¶”ì²œ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
def swing_scan():
    print("\nğŸ“ˆ ìŠ¤ìœ™ ìŠ¤ìº” ì‹œì‘")
    symbols = get_all_krw_symbols()
    message_lines = ["ğŸ“ˆ [ìŠ¤ìœ™ í›„ë³´ ë¦¬ìŠ¤íŠ¸]"]
    strong_lines = ["ğŸ”¥ [ì´í‹€ ì—°ì† ìŠ¤ìœ™ ì¡°ê±´ ë§Œì¡±]"]
    found = False
    strong_found = False
    prev_day_set = load_previous_candidates()

    for coin in symbols:
        candles = get_daily_candles(coin)
        if len(candles) < 30:
            continue

        closes = [c['trade_price'] for c in reversed(candles)]
        volumes = [c['candle_acc_trade_volume'] for c in reversed(candles)]
        current_price = closes[-1]

        rsi = calculate_rsi(closes)
        macd, signal = calculate_macd(closes)
        ma20 = calculate_ma(closes, 20)
        vol_ratio = calculate_volatility_ratio(volumes)
        drawdown = calculate_drawdown(closes)

        if rsi is None or macd is None or signal is None or ma20 is None:
            print(f"[{coin}] âŒ ì§€í‘œ ê³„ì‚° ì‹¤íŒ¨ â†’ ê±´ë„ˆëœ€")
            continue

        # ì¡°ê±´: RSI < 45, MACD > Signal, ê±°ë˜ëŸ‰ ê¸‰ë“±, MA20 ìƒíšŒ, ë‚™í­ -5% ì´ìƒ
        if rsi < 45 and macd > signal and vol_ratio > 1.5 and current_price > ma20 and drawdown <= -5:
            found = True
            save_swing_candidate(coin, rsi, macd, signal, vol_ratio, current_price)
            save_swing_position(coin, current_price)
            line = f"- {coin} | RSI: {rsi:.2f} | MACD: {macd:.4f} > SIG: {signal:.4f} | ê±°ë˜ëŸ‰ x{vol_ratio:.2f} | ë‚™í­: {drawdown:.2f}%"
            message_lines.append(line)
            print(f"âœ… í›„ë³´: {line}")

            if coin in prev_day_set:
                strong_found = True
                strong_lines.append(f"âœ… {coin} â†’ ì´í‹€ ì—°ì† ì¡°ê±´ ë§Œì¡±")
        else:
            print(f"[{coin}] ì¡°ê±´ ë¶ˆì¶©ì¡± â†’ ìŠ¤í‚µ (RSI: {rsi:.2f}, MACD: {macd:.4f}, Signal: {signal:.4f}, Vol: {vol_ratio:.2f}, DD: {drawdown:.2f})")


        time.sleep(0.2)

    if found:
        bot.send_message(chat_id=CHAT_ID, text="\n".join(message_lines))
    else:
        bot.send_message(chat_id=CHAT_ID, text="ğŸ“‰ ì˜¤ëŠ˜ ìŠ¤ìœ™ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤.")

    if strong_found:
        bot.send_message(chat_id=CHAT_ID, text="\n".join(strong_lines))

# ìŠ¤ì¼€ì¤„ ë“±ë¡
schedule.every().day.at(SWING_SCAN_TIME).do(swing_scan)
schedule.every().day.at(SWING_POSITION_TIME).do(update_swing_positions)
schedule.every().day.at(ANALYZE_POSITION_TIME).do(analyze_completed_positions)

print("ğŸŸ¢ ìŠ¤ìœ™ ë´‡ ì‹¤í–‰ë¨ (ìŠ¤ìº”: 09:05 / ì¶”ì : 09:07 / ë¶„ì„: 09:10)")
while True:
    schedule.run_pending()
    time.sleep(1)
